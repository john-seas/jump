####################################################################################################
#         __   __  __   __  ___   ____ 
#        / /  / / / /  /  |/  /  / __ \
#   __  / /  / / / /  / /|_/ /  / /_/ /
#  / /_/ /  / /_/ /  / /  / /  / ____/ 
#  \____/   \____/  /_/  /_/  /_/      
#
# John's Universal Macro Preprocessor (JUMP) V1.0
#
# This script is a universal preprocessor for Python code blocks in markdown files. 
# It allows for the execution of Python code snippets embedded within a text document, 
# capturing their output, and replacing the original code blocks with the output.
#
# Created by: John Davis
# Email: johndavis@g.harvard.edu
#
# Usage: python3 jump.py [-options] <filename> [<output_filename>]
#   Options:
#   -l <py_line_ending>: Optional line ending for Python code blocks, default is empty string.
#   -p <PARAM_PATH>: Optional path to a file containing parameters.
#   -v : Optional verbose output.
#
# #################
# # Mini Tutorial #
# #################
#
# Embedding Python is pretty easy. Simply enclose it between ```py and ``` blocks.
# Anything you print() gets rendered in the output file.
# You can also pass a parameter file path with the -p option.
#
#   Example: mytxt.jump
#       ~ This is normal text file contents and will render exactly as written.
#       ~
#       ~ ```py
#       ~ print("This text is generated by Python! Below is the parameter path passed in:")
#       ~ print(PARAM_PATH)
#       ~ ```
#       ~
#       ~ This is normal text file contents again.
#
#   Command: python3 jump.py -p myparams.json mytxt.jump mytext.txt
#
#   Output: mytxt.txt
#       ~ This is normal text file contents and will render exactly as written.
#       ~
#       ~ This text is generated by Python! Below is the parameter path passed in:
#       ~ myparams.json
#       ~
#       ~ This is normal text file contents again.
#
####################################################################################################

import re
import sys
import traceback
import io
import os

def preprocess(filename, filename_out=None, py_line_ending='', PARAM_PATH=None, verbose=False):

    if filename_out is None:
        filename_out = filename + ".txt"

    with open(filename, 'r') as f:
        lines = f.readlines()

    output = []
    python_code = []
    in_python_block = False

    exec_context = {
        'PARAM_PATH': PARAM_PATH if PARAM_PATH is not None else {},
    }

    for line in lines:
        stripped = line.strip()

        if stripped.startswith('```py'):
            #Begin Python block
            in_python_block = True
        elif stripped.startswith('```'):
            #End Python block
            in_python_block = False

            # If the Python block is not empty, execute it and empty the list
            if python_code:

                code_to_exec = '\n'.join(python_code)
                
                #Uncomment this to print the code getting executed
                #print(f"Executing Python code:\n{code_to_exec}")

                try:
                    old_stdout = sys.stdout
                    sys.stdout = mystdout = io.StringIO()
                    exec(py_line_ending.join(python_code), exec_context)
                    exec_context['output'] = mystdout.getvalue().splitlines()
                except Exception as e:
                    sys.stdout = old_stdout
                    print("!!! ERROR DURING EXECUTION:")
                    print('--- Python Code ---')
                    print(py_line_ending.join(python_code))
                    print('--- Exception ---')
                    traceback.print_exc()
                    sys.exit(1)
                finally:
                    sys.stdout = old_stdout

    
                python_code = []


                #The output from the Python block should be appended to the output
                output.append('\n'.join(exec_context.get('output', [])) + '\n')

                #Uncomment this to print the output that got executed
                #print(f"Output from Python block:\n{exec_context.get('output', [])}")

                exec_context['output'] = []

        elif in_python_block:
            python_code.append(line)
        else:
            output.append(line) #normal line, not in Python block

    with open(filename_out, 'w') as f:
        if verbose:
            print(f"Writing output to {filename_out}")
            print(f"Current working directory: {os.getcwd()}")
            print(f"File name: {filename_out}")

        f.writelines(output)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python jump.py [-options] <filename> [<output_filename>]")
        print("Optional arguments:")
        print("  <output_filename>: If not provided, the output will be saved with the same name as the input file but with a .txt extension.")
        print("  -l <py_line_ending>: Optional line ending for Python code blocks, default is empty string.")
        print("  -p <PARAM_PATH>: Optional path to a JSON file containing parameters.")
        print("  -v : Optional verbose output.")

        sys.exit(1)

    # Parse command line arguments
    py_line_ending = ''
    PARAM_PATH = None
    verbose = False

    args = sys.argv[1:]

    while(args and args[0].startswith('-')):
        if args[0] == '-l':
            py_line_ending_index = args.index('-l') + 1
            if py_line_ending_index < len(args):
                py_line_ending = args[py_line_ending_index]
                args.pop(py_line_ending_index - 1)
                args.pop(py_line_ending_index - 1)
        elif args[0] == '-p':
            param_path_index = args.index('-p') + 1
            if param_path_index < len(args):
                PARAM_PATH = args[param_path_index]
                args.pop(param_path_index - 1)
                args.pop(param_path_index - 1)
        elif args[0] == '-v':
            verbose = True
            param_path_index = args.index('-v') + 1
            args.pop(param_path_index - 1)
        else:
            print(f"Unknown option: {args[0]}")
            sys.exit(1)

    # Remaining args should be the filename and optional output filename
    if len(args) < 1:
        print("Error: No input file specified.")
        sys.exit(1)
    
    filename = args[0]
    filename_out = args[1] if len(args) > 1 else None

    if(verbose):
        print(f"Processing file: {filename}")
        print(f"Output file: {filename_out if filename_out else 'None'}")
        print(f"Python line ending: '{py_line_ending}'")
        print(f"PARAM_PATH: {PARAM_PATH}")

    # real quick just check if the files exist
    if not os.path.exists(filename):
        print(f"Error: Input file '{filename}' does not exist.")
        sys.exit(1)

    preprocess(filename, filename_out, py_line_ending, PARAM_PATH)
